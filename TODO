- useful env vars like WINDOW?
- better checking/emulation for missing term requirements
- alt charset, borders etc (terminfo(5)/Line Graphics)
- new window command prompt
- mouse handling and some other bits elinks needs
- line mode/char-at-a-time mode a la telnet?
- handle ioctl/termios stuff on window sockets
- figure out once and for all what is going on with backspace and del
      backspace should be translated per the termios setting.
      del passed through?
- window creation/idle time
- profile/optimise, particularly (i suspect) input.c
- decide about customised status line
- could use bsearch all over the place or get rid of smaller tables (clientmsg)
- better errors when creating new windows/sessions (how?)
- commands should have to care less about CMD_KEY
- session with CMD_NOSESSION should be an error
- each command should have a print op as well for list keys
- Implicitly add exec to the commands for new windows (switch to disable it)
- nested sessions, ie session as window - moving to it moves into session
  (remembering parent)
- Nested sessions over the network, plug-in another tmux as a window/subsession
- it would be nice to have multichar commands so you could have C-b K K for
  kill-window to limit accidental presses
- status-fg/status-bg should be able to set attributes: bold, etc
- save/restore (DECSC/DECRC) are ugly. maybe a struct screen_attr and memcpy
- force maximum terminal size (centred?)
- per-session toolbar state, other options
- force-default option: assume terminal supports default colours even if AX
  is missing (like, eg, xterm-color in an aterm)
- refer to windows by name etc (duplicates? fnmatch?)
- commands:
	start server
	kill server
	show-options command
	command to run something without a window at all?
	command to insert a key (or other data...) into a window (send-key)
		should paste-buffer become send-buffer.....
	command to purge window history
 	extend list-clients to list clients attached to a session (-a for all?)
	bring back detach-session to detach all clients on a session?
	paste buffer etc shouldn't be limited to keys
	buffer manip: clear, view etc
- function groups, bind-key ^W { select-window 0; send-key ^W } etc
- allow fnmatch for -c, so that you can, eg, detach all clients
- session specification is all over the place. some things use -s before cmd,
  some -s after, some no -s, there are various uses of -n. the differences are
  sort of logical, but confusing. needs rethought
- XXX should -i for win idx be before cmd too??
- bind non prefix keys
- stuff like rename would be nice to be able to do in-client like screen, if
  it could be implemented in a non-icky way
- there is to much redrawing. use flags?
- command mode (! + type tmux command)
- garbage collect window history (100 lines at a time?) if it hasn't been used
  in $x time (need window creation/use times)
- lift SHRT_MAX limits for history
- audit copy/scroll and other modes for problems with very small windows
- screen_draw_* moved out/renamed (accept TTY_*?)
- get rid of stderr/stdout hacks in log.c
- chmod +x socket when any client is attached
- split clients into three RB trees by fd: attached/unattached/dead?
  or tailqs? what would be fastest per-char?
- everything should write via a screen and modes should be done by switching
  screen out

-- For 0.2 --------------------------------------------------------------------
- window splitting?
- restore term cap checks ****
- anything which uses cmd_{send,recv}_string will break if the string is
  split. string length should be part of the command size
- echo \\033[35\;46m\\033[2J last line quirk (with C-b r)
- quick intro section (tmux new/attach/detach) etc
- is ACS the right way round??

--------

screen redraw.

ops:
- redraw screen or section of screen to tty without altering it
	(screen-redraw.c, screen_redraw_ctx)
	(switching screen etc)
- draw to screen and optionally tty
	(window output)
	(screen-write.c, screen_write_ctx)
- copy line/column from one screen (inc history) at offset??
	(scroll/copy mode)

--------
kmous -- \E[M

mouse init:     putp("\033[?1000h");
mouse deinit:   putp("\033[?1000l");

\e[M CbCxCy
         * On button press or release, xterm sends ESC [ M CbCxCy.
         * The low two bits of Cb encode button information: 0=MB1
         * pressed, 1=MB2 pressed, 2=MB3 pressed, 3=release.  The
         * upper bits encode what modifiers were down when the
         * button was pressed and are added together.  4=Shift,
         * 8=Meta, 16=Control.  Cx and Cy are the x and y coordinates
         * of the mouse event.  The upper left corner is (1,1).


       get_mouse                 getm     Gm   Curses should get
                                               button events
       key_mouse                 kmous    Km   Mouse event has
                                               occurred
       mouse_info                minfo    Mi   Mouse status
                                               information
